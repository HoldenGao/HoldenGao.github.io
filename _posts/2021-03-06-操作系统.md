---
layout: post
title: 操作系统
tags: [operating system]
comments: true
thumbnail-img: "/assets/img/blog/LinuxPenguin.png"
share-img: ""
typora-copy-images-to: ../assets/img/blog
typora-root-url: ..
---

[toc]

### 一、操作系统

#### 1.1_1 操作系统的概念，功能和目标

常见操作系统：windows、andriod、ios、Macos、linux

操作系统的概念：（operating system，OS） 是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供用户和其他软件方便的接口和环境，他是计算机系统最基本的**系统软件**。

> 操作系统的功能和目标：

补充知识：进程是一个程序的执行过程，**执行前需要讲该程序放到内存中**，才能被CPU处理

1. 作为系统资源的管理者：
   1. QQ聊天时，打开文件夹找到QQ.exe-----**文件管理**
   2. 需要把该程序放到内存中----**存储器管理（内存管理）**
   3. 对应的进程被处理机（cpu）处理----**处理机管理**
   4. 需要把摄像头分配给进程----**设备管理**

2. 作为用户和计算机硬件之间的接口
   1. **命令接口**：联机命令接口（交互式）、脱机命令接口（批处理命令接口，类似于*.bat文件）
   2. **程序接口**：由一组**系统调用**组成
   3. **GUI图形用户界面**：

3. 作为接近硬件的层次
   1. 实现对硬件及其的拓展

#### 1.1_2 操作系统的特征

1. **并发**：指两个或者多个事件在同一时间间隔内发生（宏观上同时发生，微观上交替发生）。区别于**并行**（指两个或多个事件同时发生）

   一个单核处理机（CPU）同一时刻只能执行一个程序

2. **共享：**资源共享，是指可供内存中多个并发进程共同使用

   1. 互斥共享方式：一个时间段只允许一个进程访问该资源。比如QQ，微信对于摄像头的使用
   2. 同时共享方式：一个时间段由多个进程“同时”进行访问。QQ，微信同时发送同一个文件

   ***并发和共享是充要条件**，是操作系统最基本的两个特征

3. **虚拟**：把一个物理上的实体变为若干个逻辑上的对应物。空分复用技术，时分复用技术

4. **异步**：由于资源有限，进程执行不是一贯到底的，而是走走停停

#### 1.1_3 操作系统的发展和分类

1. 手工操作阶段。人机速度矛盾
2. 批处理系统。内存中仅有一道程序运行
3. 多道批处理系统。不提供人机交互
4. 分时操作系统。解决了人机交互问题，不能解决紧急任务
5. 实时操作系统。能够响应紧急任务，及时性可靠性

#### 1.1_4 操作系统运行机制，体系结构

处理器的两种状态：

	* **用户态**：此时CPU只能执行非特权指令
	* **核心态**：特权指令、非特权指令都可执行

两种程序：

	* **内核程序**：运行在核心态（特权指令、非特权指令都可执行）
	* **应用程序**：运行在用户态（只能执行非特权指令）



操作系统的内核：

内核是计算机上配置的**底层软件**，是操作系统最基本最核心的部分

![img](/assets/img/blog/841.png)

**原子性**：运行时一气呵成，不可中断

内核可以分为：大内核（包含橙色部分，高性能，结构混乱），微内核（不包含橙色部分）

#### 1.1_5 中断和异常

本质：发生中断意味着需要操作系统接入，开展管理工作

1. 当中断发生时，CPU立即进入**核心态**
2. 当中断发生后，当前运行程序暂停，并由操作系统内核对中断进行处理（进入核心态）
3. 对于不同中断信号，会进行不同的处理



**用户态转为核心态，中断是唯一途径**

核心态转为用户态，只需要设置一个PSW（程序状态字）即可



中断的分类：

1. 内中断（信号来源于**CPU内部**，与**当前执行的指令有关**，也称为异常/例外/陷入）
   1. 自愿中断（trap）
   2. 强迫中断（abort）
2. 外中断（信号来源于**CPU外部**，与**当前执行的指令无关**，也称为狭义中断）
   1. 外设请求：如IO操作发出的中断信号
   2. 人工干预：用户强制停掉一个进程

#### 1.1_6 系统调用

应用程序通过**系统调用**请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，**凡是与资源有关**的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，有操作系统代为完成。这样可以保证**系统的稳定性和安全性**，防止用户非法操作

系统调用的相关处理在**核心态**进行





### 二、进程

#### 2.1_1进程的定义、组成、组织方式、特征

程序：就是一个指令序列

进程：**程序段，数据段，PCB**（进程控制块，用来描述进程的各种信息）三部分组成了进程实体，简称为进程。

**PCB是进程存在的唯一标识！**，创建/撤销进程就是创建/撤销PCB

**进程是动态的**



进程控制块：

![进程控制块（PCB）](/assets/img/blog/2-1Q1011J630138.gif)



进程的组织方式：

1. 链接方式：执行指针；就绪队列指针；阻塞队列指针。
2. 索引方式：执行指针；就绪队列指针；阻塞队列指针。



进程特征：

1. 动态性。**最基本特征**
2. 并发行
3. 独立性。**进程是资源分配，接受调度的基本单位**
4. 异步性
5. 结构性

#### 2.1_2 进程的状态与转换

三种基本状态：

1. 运行态。每个核可以运行一个进程，双核可以同时运行两个进程
2. 就绪态。万事俱备，只欠CPU
3. 阻塞态
4. 创建态
5. 终止态



进程状态之间的转换

![进程状态转换与线程状态转换的区别_Horace Ho的博客-CSDN博客](/assets/img/blog/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ob3JhY2VoZS5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70.png)



#### 2.1_3 进程控制

进程控制就是要实现进程状态之间的转换。

开/关中断指令的权限非常大，必须只允许在核心态下执行的特权指令

进程控制使用原语实现

过程：

1. 更新PCB信息
2. 将PCB插入合适的队列
3. 分配/回收资源





#### 2.1_4 进程通信

进程通信指的是进程之间的信息交换

进程是分配系统资源的单位，因此各进程的内存地址空间相互独立



方式一：**共享存储**

两个进程对共享空间的访问**必须是互斥**的

分为两种

1. 基于数据结构的共享
2. 基于存储区的共享

方式二：**管道通信**

1. 半双工通信
2. 互斥的
3. 管道写满，写进程阻塞；管道变空，读进程阻塞
4. 管道没写满，不能读；没读空，不能写
5. 只能有一个读进程（管道数据读完就抛弃了）

方式三：**消息传递**

进程间的数据交换以**格式化消息**为单位



#### 2.1_5 线程概念和多线程模式

线程是一种“轻量级进程”

**引入线程之后，<u>进程是资源分配的基本单位，线程是调度的基本单位</u>**



线程控制块（TCB）

切换同进程的线程，系统开销很小，不需要切换运行环境



分类：

1. 用户级线程：用户可以看到，操作系统看不到。
2. 内核级线程：需要在核心态下完成。操作系统能看到

**操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单元**



多线程模型：

1. 多用户级线程对一个内核级线程。并发性差
2. 一对一：一个用户级线程映射到一个内核级线程。并发能力高
3. 多对多：n个用户级线程映射到m个内核级线程（n>=m）。克服了多对一并发性差的缺点，又克服了一对一模型中内核切换开销大的问题

#### 2.2_1处理机调度的概念、层次

**按照一定的算法选择一个进程**并将处理机分配给它运行



高级调度：作业调度

中级调度：内存调度

低级调度：进程调度，最基本的一种调度

![img](/assets/img/blog/100.jpeg)



#### 2.2_2 进程调度的时机、切换与过程、方式

需要进行进程调度和切换的情况：

1. 当前运行的程序主动放弃处理机
   1. 进程正常终止
   2. 发生异常终止
   3. 进程主动请求阻塞
2. 被动放弃
   1. 时间片用完
   2. 有更紧急的事要处理
   3. 有更高优先级的进程进入就绪队列

不能进行进程调度的情况：

1. 在处理中断的过程中
2. 进程在操作系统内核程序临界区。普通临界区是可以进行调度的，比如打印机
3. 原子操作过程中



**临界资源**：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源

**临界区**：访问临界资源的那段代码



进程调度方式：

1. 非剥夺调度方式
2. 剥夺调度方式。可以优先处理更紧急的进程



进程的切换：

1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复



进程切换有代价，频繁的进程切换会影响运行效率



#### 2.2_3调度算法的评价指标

CPU利用率：忙碌的时间/总时间

系统吞吐量：单位时间内完成作业的数量

周转时间：作业完成时间-作业提交时间

等待时间：对于**进程**来说就是进程简历后等待被服务的时间之和；对于**作业**来说，不仅要考虑简历进程后的等待时间，还要加上作业在外存后备队列中的等待时间

响应时间：提交到首次响应所用的时间



#### 2.2_4 FCFS、SJF、HRRN调度算法

##### 1. 先来先服务FCFS

非抢占式算法

对长作业有利，对段作业不利。



##### 2. 短作业优先SJF（shortest job first）

时间最短的作业/进程优先得到服务

有两种：抢占式和非抢占式

对短作业有利，长作业不利

##### 3. 高响应比优先HRRN（highest response ratio next）

综合考虑等待时间和要求服务时间

响应比=（等待时间+要求服务时间）/要求服务时间 >=1



#### 2.2_5 时间片轮转、优先级、多级反馈队列



1. 时间片轮转（RR, Round-Robin）

   常用于分时操作系统

   如果时间片太大，则该算法退化为FCFS算法；时间片太小，导致进程切换太多

2. 优先级调度算法

   系统进程优先于用户进程

   前台进程优于后台进程

   

3. 多级反馈队列调度算法

综合了前面的所有算法优点

类似于去饭店吃饭，先给来个凉菜，再给来个热菜，最后上时间最长的汤

![在这里插入图片描述](/assets/img/blog/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lyeDQyMDkwOQ==,size_16,color_FFFFFF,t_70.png)

#### 2.3_1 进程同步、进程互斥

进程互斥四个部分：

1. 进入区：检查是否可以进入，若进入，需要上锁
2. 临界区：**访问临界资源的代码段**
3. 退出区：负责解锁
4. 剩余区

为了实现对临界资源的互斥访问，需要遵循一下原则：

1. 空闲让进
2. 忙则等待
3. 有限等待
4. 让权等待



#### 2.3_2 进程互斥的软件实现方法

1. 单标志法

![在这里插入图片描述](/assets/img/blog/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0YXJ0ZXJfX19fXw==,size_16,color_FFFFFF,t_70-20210306215651748.png)

2. 双标志先检查法

3. 双标志后检查法
4. Peterson算法



#### 2.3_3 进程互斥的硬件实现方法

1. 中断屏蔽方法：开/关中断指令
2. TestAndSet指令
3. Swap指令

#### 2.3_4 信号量机制

信号量其实是一个变量（可以是一个整数，也可以是更复杂的记录型变量），**表示系统中某种资源的数量**，比如打印机数量等 



一对原语：wait(S)和signal(S)（也可以写为P(S)和V(S)）

两种信号量：

1. 整形信号量
2. 记录型信号量

#### 2.3_5 信号量实现进程互斥、同步、前驱关系

1. 信号量实现互斥

   不同的临界资源需要设置不同的互斥信号量

   **信号量初始值设为1**

2. 信号量机制实现进程同步：

![img](/assets/img/blog/1358881-20190915135612260-1362223675.png)

3. 信号量机制实现前驱操作

   ![img](/assets/img/blog/1358881-20190915140319276-1184668052.png)

#### 2.3_6 生产者消费者问题

缓冲区是临界资源，各进程需要互斥

需要三个信号量：

1. 互斥信号量，表示对缓冲区的互斥访问
2. 同步信号量，表示空闲缓冲区的数量
3. 同步信号量，表示产品的数量，也即非空缓冲区的数量



实现互斥操作是同一个进程之间进行PV操作的，同步操作PV是两个进程中的

互斥的P一定要放在同步的P之后，而且互斥直接放在访问资源前后放上PV就行

#### 2.3_7 多生产者多消费者问题

四个信号量

![操作系统——多生产者多消费者问题- 王陸- 博客园](/assets/img/blog/1358881-20190917082258130-832471420.png)

#### 2.3_8 吸烟者问题

![操作系统——吸烟者问题- 王陸- 博客园](/assets/img/blog/1358881-20190917154021913-2124204920.png)



#### 2.3_9 读者写者问题

#### 2.3_10 哲学家吃饭问题

#### 2.3_11 管程

管程是一种高级同步机制，比PV操作简单

外部进程/线程只能通过管程中提供的特定“入口”才能访问数据

每次仅允许一个进程在管程内执行某个内部过程



#### 2.3_12 **死锁**

>  死锁：
>
> 在并发环境下，各进程因为竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象，就是死锁



> 饥饿
>
> 由于长时间得不到想要的资源，某进程无法向前推进。比如短进程有限（SPF）算法中，若有源源不断的短进程到来，则长进程一直处于饥饿状态

> 死循环
>
> 某进程一直跳不出某个循环的现象



##### 1.死锁产生必要条件

	* 互斥条件
	* 不剥夺条件
	* 请求和保持条件。进程已经保持了至少一个资源，但是又提出**新的资源请求**，而该资源又被其他进程占有，因此请求被阻塞，但又对**已有资源保持不放**
	* 循环等待。循环等待未必死锁，但是死锁一定循环等待

什么时候发生死锁：

1. 对系统资源竞争
2. 进程推进顺序非法。进程P1，P2分别拥有R1和R2，然后P1和P2分别区申请R2和R1，就会导致死锁
3. 信号量使用不当（eg. 互斥的P操作在实现同步的P操作之前）

总之，对不可剥夺资源的不合理分配，可能导致死锁



##### 2.死锁的处理策略

1. 预防死锁。破坏死锁产生的四个必要条件中的一个或者几个
2. 避免死锁
3. 死锁的检测和解锁





> 预防死锁

1.破坏互斥条件。比如SPOOLing技术

2.破坏不剥夺条件

3.破坏请求和保持。可以采用静态分配方法。资源利用率低，可能导致饥饿

4.破坏循环等待条件。顺序资源分配法





> 避免死锁

银行家算法

安全序列



> 死锁的检测和接触

死锁检测算法：

依次消除与不阻塞进程相连的边，知道无边可消

如果资源分配图不可完全简化，说明发生了死锁





### 三、内存

内存时存放数据的硬件。程序执行前需要放到内存中才能被CPU处理

从写程序到程序运行过程：

编辑-编译-链接-装入

**装入的三种方式：**

1. 绝对装入。程序中使用绝对地址
2. 静态重定位。装入时对地址进行重定位，将逻辑地址变换为物理地址
3. 动态重定位。需要一个重定位寄存器。地址转换推迟到程序真正运行时才转。**现在操作系统使用**



**链接的三种方式：**

1. 静态链接。装入前链接成一个完整的装入模块
2. 装入时动态链接。装入内存时，边装入边链接
3. 运行时动态链接。运行时需要目标某块才装入并链接

#### 3.1_2 内存管理*******

1. 内存空间的分配和回收
2. 内存空间扩充
3. 地址转换。逻辑地址转换为物理地址（三种装入方式）
4. 内存保护。各个进程只能访问自己的地址空间
   1. 上下限寄存器
   2. 重定位寄存器和界地址寄存器



#### 3.1_3 内存空间扩充--覆盖和交换

1. 覆盖技术（不常用了）：

将程序分为多个段，常用的段驻内存，不常用的段在需要时调入内存。

内存中分为一个固定区域和若干个覆盖区，常用的放在固定区，不常用的放在覆盖区

缺点：不好使用，对编程要求高



2. 交换技术：

和中级调度一样。内存空间不足时，将内存中某些进程暂时换到外存中挂起，只保留PCB。

7状态图

具有兑换功能的操作系统中，通常把磁盘空间分为文件区和对换区。文件区存放文件，采用离散分配方式，主要追求存储空间利用率；对换区存放换出的进程数据，采用连续存储分配，主要追求换入换出速度。



#### 3.1_4 内存空间的分配与回收

可以分为：

1. 连续分配管理方式。（连续的内存空间）
   1. 单一连续分配。有内部碎片，无外部碎片
   2. 固定分区分配。维护一个分区表。有内部碎片，无外部碎片
   3. 动态分区分配。不会预先划分内存分区，根据进程大小动态建立分区
2. 非连续分配管理
   1. 基本分页存储管理
   2. 基本分段存储管理
   3. 段页式存储管理



内部碎片：分配给某进程的内存区域中，如果有些部分没有用上

外部空间：是指内存中的某些空闲分区由于太小而难以利用



#### 3.1_5 动态分区分配算法

1. 首次适应算法
2. 最佳适应算法。分区链表从小到大排列。会产生很多外部碎片
3. 最坏适应算法。分区链表从大到小排列。大分区过早的分完
4. 邻近适应算法



#### 3.1_6 基本分页存储管理的基本概念

基本分页存储管理

基本分页存储管理的思想——**把内存分为一个个相等的小分区**,再按照分区大小把进程拆分成一个个小部分

操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说,**进程的页面与内存的页框有一一对应的关系。**
各个页面不必连续存放,也不必按先后顺序来,可以放到不相邻的各个页框中。



**总结：分页存储管理中,如何实现地址换?**
1.要算出逻辑地址对应的页号
2.要知道该页对应页面在内存中的起始地址
3.要算逻辑地址在页面内的“偏移量”
4.物理地址=页面始址+页内偏移量



为了能知道进程的每个页面在内存中存放的位置,操作系统要为每个进程建立一张页表



![IMG_0003](/assets/img/blog/IMG_0003.PNG)



#### 3.1_7 基本地址变换机构

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址

通常会在系统中设置一个**页表寄存器（PTR）**，存放**页表在内存中的起始地址F**和页**表长度M**

CPU访问内存单元的过程中需要两次访问内存：

第一次： 查询页表。找到对应的页表项，拿到内存块号

第二次：访问目标内存单元。访问目标存储单元



![在这里插入图片描述](/assets/img/blog/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-20210307220128939.png)

#### 3.1_8 具有快表的地址变换机构

是基本地址变换机构的改进版本

**时间局部性**：指令或者数据在访问后，不久后可能会再次被访问。因为程序存在大量循环

**空间局部性**：程序访问存储单元，其附近的存储单元也可能被访问。因为很多数据在内存中连续存放

**快表**，又称为**联想存储器（TLB）**，是一种访问速度比内存快很多的**高速缓冲存储器**，用来存放之前访问的若干页表项，以加速地址变换过程。与此对应，内存中的页表常称为**慢表**。

![内存管理—— 快表TLB_starter_____的博客-CSDN博客](/assets/img/blog/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0YXJ0ZXJfX19fXw==,size_16,color_FFFFFF,t_70-20210307221233100.png)

![内存管理—— 快表TLB_starter_____的博客-CSDN博客](/assets/img/blog/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0YXJ0ZXJfX19fXw==,size_16,color_FFFFFF,t_70-20210307221716035.png)



#### 3.1_9 两级页表

单级页表的问题：

1. 页表必须连续存放，因此页表很大，需要占用多个连续的页框
2. 没有必要让整个页表常驻内存

类似于书本太大，需要增加一个二级目录来记录原来的目录（个人理解）

#### 3.1_10基本分段存储管理方式

与“分页”最大的区别就是---离散分配是所分配的地址空间的基本单位不同

进程的地址空间：按照程序自身的**逻辑关系划分**为若干个段，每段从0开始编址

![img](/assets/img/blog/963196997_1596358646958_067EAFAA2665EE72EABC548BB226199E.png)

分段和分页的比较：

- 页是信息的物理单位, 分页的主要目的是为了实现离散分配, 提高内存利用率. 分页仅仅是系统管理上的需要, 完全是系统行为, **对用户是不可见**的
- 段是信息的逻辑单位, 分段的主要目的是更好地满足用户需求. 一个段通常包含着一组属于一个逻辑模块的信息, 分段**对用户是可见**的, 用户编程时需要显式地给出段名
- 页的大小是**固定**且由系统决定, 段的长度却**不固定**, 决定于用户编写的程序
- 分页的用户进程地址空间是一维的, 分段的用户进程是二维的.

3.1_11 段页式管理

|   优点   |                            缺点                            |                                                              |
| :------: | :--------------------------------------------------------: | ------------------------------------------------------------ |
| 分页管理 | 内存空间利用率高. 不会产生外部碎片, 只有少量的**内部碎片** | 不方便逻辑模块实现信息的**共享与保护**                       |
| 分段管理 |              方便实现逻辑模块信息的共享与保护              | 如果段长过大, 为其分配很大的连续空间会很不方便, 并且段式管理会**产生外部碎片** |

![img](/assets/img/blog/963196997_1596358649091_C93E7E2B40706A717979DF2A295F7214.png)

#### 3.2_1 虚拟内存

虚拟内存是内存空间扩充的一种技术

传统内存管理方式：连续分配管理和非连续分配管理（见3.1_4），一次性，驻留性



高速缓存技术：将近期会频繁访问到的数据放到更加高速的存储器中，在那时用不到的数据放到更低速存储器中

<img src="/assets/img/blog/1365470-20181218113203505-254240949.png" style="zoom:50%;" />

![在这里插入图片描述](/assets/img/blog/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0YXJ0ZXJfX19fXw==,size_16,color_FFFFFF,t_70-20210308002635486.png)

**虚拟内存的三个特征：**

1. 多次性：无需再作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
2. 对换性：再作业运行时无需一直常驻内存，而是允许再作业运行过程中，将作业换入、换出。
3. 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际容量。

<img src="/assets/img/blog/2035133-20200615134634564-1866261030.png" alt="img" style="zoom: 44%;" />

#### 3.2_2 请求分页管理方式

中段类型：

![img](/assets/img/blog/1358881-20190531192959960-1818513138.png)

和基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存；如果没有调入，需要知道该页面在外存中的哪个地方。
 另一方面，当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪些页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖。因此，操作系统也需要记录各个页面是否被修改的信息。
 请求分页管理方式的页表信息如下：

![img](/assets/img/blog/954.png)



#### 3.2_3 页面置换算法

1. 最佳置换算法（无法实现）

   每次选择**以后永不使用**的淘汰，或者在**最长时间内不再被访问**的页面

2. 先进先出置换算法

   每次淘汰的页面是最早进入内存的页面

3. 最近最久未使用置换算法

   每次淘汰的页面是最近最久未使用的页面

4. 时钟置换算法（Clock）

5. 改进型时钟置换算法

   ![img](/assets/img/blog/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0YXJ0ZXJfX19fXw==,size_16,color_FFFFFF,t_70-20210308012026901.png)

#### 3.2_4 页面分配策略

驻留集：指请求分页存储管理中给进程分配的物理块的集合

在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小

例如：考虑一个极端的情况，若某进程共有100个页面，则该进程的驻留集大小为100时可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会特别频繁的缺页。

![在这里插入图片描述](/assets/img/blog/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW96aGl3ZWkzMTQ=,size_16,color_FFFFFF,t_70.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210215170231995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW96aGl3ZWkzMTQ=,size_16,color_FFFFFF,t_70)



> 何时调入页面

![在这里插入图片描述](/assets/img/blog/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW96aGl3ZWkzMTQ=,size_16,color_FFFFFF,t_70-20210308014416393.png)



> 从何处调入

![在这里插入图片描述](/assets/img/blog/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW96aGl3ZWkzMTQ=,size_16,color_FFFFFF,t_70-20210308014623832.png)